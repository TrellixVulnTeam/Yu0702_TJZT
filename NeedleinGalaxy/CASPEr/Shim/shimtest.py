import numpy as np
from scipy import signal
import matplotlib
#matplotlib.use('Qt5Agg')
import matplotlib.pyplot as plt

from matplotlib.colors import LogNorm
import matplotlib.gridspec as gridspec

import time
import sys
from lmfit import Parameters, minimize, report_fit, Model
from scipy.optimize import curve_fit



def Lorentzian(
		x=1,
		amp=1,
		FWHM=50,
		pkloc = 0,
):
	return  amp / (1 + ((x - pkloc) / (0.5 * FWHM)) ** 2)

# gyromagnetic ratio
gp = 4.25775*10**1
cpfactor = 0.050
# B field data generated by simulation for testing algorithm
Bdataset_00_00_00 = "Mag_Map_2021_0903 (8).txt"
Bdataset_00_00_05 = "Mag_Map_2021_0901 (2).txt"
Bdataset_00_00_10 = "Mag_Map_2021_0901 (3).txt"
Bdataset_00_05_00 = "Mag_Map_2021_0901 (4).txt"
Bdataset_00_05_05 = "Mag_Map_2021_0901 (5).txt"
Bdataset_00_05_10 = "Mag_Map_2021_0901 (6).txt"
Bdataset_05_00_00 = "Mag_Map_2021_0901 (7).txt"
Bdataset_05_00_05 = "Mag_Map_2021_0901 (8).txt"
Bdataset_05_00_10 = "Mag_Map_2021_0901 (9).txt"
Bdataset_05_05_00 = "Mag_Map_2021_0901 (10).txt"
Bdataset_05_05_05 = "Mag_Map_2021_0901 (11).txt"
Bdataset_05_05_10 = "Mag_Map_2021_0901 (12).txt"

# current limit for each channel in amp. should it be [-2, 3]?
shimIlim = np.array([[-2, 3], [-2, 3], [-2, 3], [-2, 3], [-2, 3], [-2, 3], [-2, 3], [-2, 3]])
#np.array([[-20,30],[-20,30],[-20,30],[-20,30],[-20,30],[-20,30],[-20,30],[-20,30]])
#np.array([[-2, 3], [-2, 3], [-2, 3], [-2, 3], [-2, 3], [-2, 3], [-2, 3], [-2, 3]])
def fitpara(
		xdata=None,
		ydata=None
):


	amp = np.amax(ydata)
	minamp=np.amin(ydata)

	#for i in range(len(ydata)):
	#	print(i, ydata[i]-minamp,0.5*(amp-minamp))
	#print(amp - minamp)

	FHWM = 0
	peakloc_i = np.argmax(ydata)
	peakloc = xdata[peakloc_i]
	left = 0
	right = len(ydata)-1

	for i in np.arange(start=0,stop=peakloc_i):
		if (ydata[i]-minamp)>=0.5*(amp-minamp) and (ydata[i+1]-minamp)<=0.5*(amp-minamp):
			left = i
			break
		if (ydata[i]-minamp)<=0.5*(amp-minamp) and (ydata[i+1]-minamp)>=0.5*(amp-minamp):
			left = i
			break
	for i in np.arange(start=peakloc_i,stop=len(ydata)-1):
		if ydata[i]>=0.5*amp and ydata[i+1]<=0.5*amp:
			right = i
			break
		if ydata[i]<=0.5*amp and ydata[i+1]>=0.5*amp:
			right = i
			break

	return amp, abs(xdata[right]-xdata[left]), peakloc, left, right
def chindx(
		channelname = 'X'
):
	"""
	    Channel A ---> Shim X
		Channel B ---> Shim Z1
		Channel C ---> Shim Y
		Channel D ---> Shim Z2
		Channel E ---> Shim XY
		Channel F ---> Shim ZX
		Channel G ---> Shim ZY
		Channel H ---> Shim X2-Y2
	"""
	switch = {
		'X': 0, 'x': 0,
		'Z1': 1, 'z1': 1, 'Z': 1, 'z': 1,
		'Y': 2, 'y': 2,
		'Z2': 3, 'z2': 3,
		'XY': 4, 'xy': 4, 'Xy': 4,'xY': 4, 'YX': 4, 'yx': 4, 'yX': 4,'Yx': 4,
		'ZX': 5, 'zx': 5, 'Zx': 5, 'zX': 5, 'XZ': 5, 'xz': 5, 'xZ': 5, 'Xz': 5,
		'ZY': 6, 'zy': 6, 'Zy': 6, 'zY': 6, 'YZ': 6, 'yz': 6, 'yZ': 6, 'Yz': 6,
		'X2-Y2': 7, 'x2-y2': 7, 'X2Y2': 7,'x2y2': 7,
	}
	return switch.get(channelname, 1123)

def SHIMbysweep(
		verbose=True,
		txtlog=True,
		radialsweep = False,
		orientation = "height",
		maxstep=300,
		maxtime=60,
		chnum = 8,
		initI = np.zeros(8),
		initIrange = np.array([[-20,30],[-20,30],[-20,30],[-20,30],[-20,30],[-20,30],[-20,30],[-20,30]])
):
	Bfield = np.loadtxt(Bdataset_00_00_00)
	currspace = np.linspace(start=-2,stop=3,num=6,endpoint=True)
	shimlog = np.zeros((1,chnum + 6))

	shimI = np.array([0, 0, 0, 0, 0, 0, 0, 0])
	shimfield = rampshimBz(xyz=Bfield[:, 0:3], shimI=shimI)
	report, popt = signalfit(verbose=False, Bzfield=Bfield[:, 5], shimfield=shimfield, binumber=200, specplot=False,
							 fitplot=False)
	shimlog[0, 0:chnum] = shimI
	shimlog[0, chnum:chnum + 3] = report
	shimlog[0, chnum + 3:chnum + 6] = popt
	"""
	
	"""
	for curH in currspace:
		print('cur H = ',curH)
		print('\n')
		for curE in currspace:
			for curG in currspace:
				for curF in currspace:
					for curC in currspace:
						for curA in currspace:
							for curD in currspace:
								for curB in currspace:
									shimI = np.array([curA, curB, curC, curD, curE, curF, curG, curH])
									shimfield = rampshimBz(xyz=Bfield[:, 0:3], shimI=shimI)
									report, popt = signalfit(verbose=False, Bzfield=Bfield[:, 5], shimfield=shimfield,
															 binumber=200,
															 specplot=False, fitplot=False)
									improve = (report[0] - shimlog[0, chnum]) / shimlog[0, chnum]
									if improve > 0:
										# record best
										shimlog[0, 0:chnum] = shimI
										shimlog[0, chnum:chnum + 3] = report
										shimlog[0, chnum + 3:chnum + 6] = popt
										#print("best = ", shimlog)
										print('shim current= %g, %g, %g, %g, %g, %g, %g, %g' % (
											shimI[0], shimI[1], shimI[2], shimI[3], shimI[4], shimI[5], shimI[6], shimI[7], ))
										print('spectrum: height=%5.3f, fullwidth=%5.3f kHz, center=%5.3f MHz,\n '
											  'fit: height=%5.3f, linewidth=%5.3f kHz, center=%5.3f MHz\n' % (
												report[0], 1000 * report[1], report[2], popt[0], popt[1] * 1000,
												popt[2]))


				# signalfit(Bzfield=Bfield[:, 5], shimfield=shimfield, binumber=200,chinfo=shimch, expnumber=step, specplot=False, fitplot=True)
	print("best = ", shimlog)
	return 0

def rampshimBz(
		xyz=np.zeros((1000,3)),
		shimI = np.zeros(8)
):
	'''
	'''
	Bz = shimI[chindx('X')]*xyz[:,0]+shimI[chindx('Y')]*xyz[:,1]+shimI[chindx('Z')]*xyz[:,2]+\
		 shimI[chindx('XY')]*xyz[:,0]*xyz[:,1]+shimI[chindx('ZX')]*xyz[:,2]*xyz[:,0]+shimI[chindx('ZY')]*xyz[:,2]*xyz[:,1]+ \
		 shimI[chindx('Z2')] * (xyz[:, 2]**2 - xyz[:, 0]**2 - xyz[:, 1]**2)+\
		 shimI[chindx('X2-Y2')] * (xyz[:, 0]**2 - xyz[:, 1]**2)
	return Bz

def signalfit(
		Bzfield,
		shimfield,
		binumber = 200,
		chinfo='channel info',
		expnumber=None,
		specplot=False,
		fitplot = False,
		verbose=True
):
	if verbose:
		print(chinfo)
	#cpfactor=0.001
	spectrum, bin_edges = np.histogram(gp*(Bzfield+cpfactor*shimfield), bins=binumber, density=True) #
	frequencies = (bin_edges - (bin_edges[1]-bin_edges[0])/2.)[1:]
	amp, sigma, peakloc, left, right=fitpara(xdata=frequencies,ydata=spectrum)
	#print("amp, sigma, peakloc, left, right = ", amp, sigma, peakloc, left, right)
	#print("hist integral = ", np.sum(spectrum)*abs(bin_edges[1]-bin_edges[0]))
	freqloc = frequencies[np.argmax(spectrum)]  #
	if specplot:
		fig = plt.figure()  # figsize=(3, 2.3)
		gs = gridspec.GridSpec(nrows=1, ncols=1)  # , width_ratios=widths, height_ratios=heights
		# fig.subplots_adjust(left=0.23, bottom=0.157, right=0.971, top=0.974, wspace=0.2, hspace=0.2)
		ax0 = fig.add_subplot(gs[0, 0])
		ax0.plot(frequencies, spectrum)  # ,label = labelarr[i]  ,c='grey'
		# ax0.set_xlim(4.225, 4.270)
		# ax0.set_ylim(-4, 104)
		ax0.set_xlabel("frequency [MHz]")  # , fontsize=10
		ax0.set_ylabel("Amplitude [a.u.]")  # , fontsize=10
		ax0.set_title(chinfo+'\n freqloc = %g MHz\n predicted amp=%g, sigma=%g kHz, peakloc=%g'%(freqloc,amp, sigma* 1000, peakloc))
		# plt.savefig("D:\\Mainz\\JGU\\Specmeter\\report\\sample02mM0629UVzoomin1.png", format='png')
		plt.grid()
		plt.show()


	report = np.array([np.amax(spectrum), abs(frequencies[-1]-frequencies[0]), freqloc])
	# Lorentzian(x,amp,FWHM,pkloc)
	try:
		popt, pcov = curve_fit(Lorentzian, frequencies[max(0, left - 2):right], spectrum[max(0, left - 2):right], \
							   p0=(amp, max(0.001, sigma), peakloc))  # ,method='lm'
	except RuntimeError:
		popt = [600, 0.001 , 4.257]

	#perr = np.sqrt(np.diag(pcov))

	if fitplot:
		fig = plt.figure(figsize=(7, 4))  #
		#fig.canvas.manager.window.move(0)
		#plt.get_current_fig_manager().window.SetPosition((500, 0))
		gs = gridspec.GridSpec(nrows=1, ncols=1)  # , width_ratios=widths, height_ratios=heights
		# fig.subplots_adjust(left=0.23, bottom=0.157, right=0.971, top=0.974, wspace=0.2, hspace=0.2)
		ax1 = fig.add_subplot(gs[0, 0])

		#mngr = plt.get_current_fig_manager()
		# to put it into the upper left corner for example:
		#mngr.window.setGeometry(50, 100, 640, 545)
		ax1.plot(frequencies, Lorentzian(frequencies, *popt),'g')  # ,label='fit: a=%5.3f, b=%5.3f, c=%5.3f, d=%5.3f' % tuple(popt)
		ax1.scatter(frequencies, spectrum,marker='o',s=10)
		#ax1.set_xlim(4.225, 4.270)
		#ax1.set_ylim(-4, 104)
		ax1.set_title('spectrum: height=%5.3f, fullwidth=%5.3f kHz, center=%5.3f MHz,\n '
					  'fit: height=%5.3f, linewidth=%5.3f kHz, center=%5.3f MHz, expnumber=%d\npredicted amp=%g, sigma=%g, peakloc=%g' % (
		report[0], 1000 * report[1], report[2], popt[0], popt[1] * 1000, popt[2], expnumber,amp, sigma* 1000, peakloc))
		# plt.savefig('1pulse/' + str(expnumber) + '/fit.pdf')
		plt.grid()
		plt.show()

	return report, popt



	#return 0

def SHIMby1stpass(
    	verbose=True,
		txtlog=True,
		radialsweep = False,
		orientation = "height",
		maxstep=300,
		maxtime=60,
		divnum = 6,
		chnum = 8,
		initI = np.zeros(8),
		initIrange = np.array([[-20,30],[-20,30],[-20,30],[-20,30],[-20,30],[-20,30],[-20,30],[-20,30]])
):
	"""
	shimming algorithm: First pass.
	    See book Shimming Ain't Magic: The Shimming of High Resolution NMR Magnets by V. W. Miner and W. W. Conover
	"""
	Bfield = np.loadtxt(Bdataset_00_00_00)  # print("shape of B field = ", Bfield.shape)
	sequence1stpass = np.array(['Z1','Z2','X','Y','ZX','X','ZY','Y','XY','X2-Y2'])
	step = 0
	layer = 0

	# shim log format
	# chA B ... until H (spectrum)height fullwidth peaklocation (fit)height FWHM area peakposition
	shimlog = np.zeros((maxstep+2,chnum+6))
	shimrange = initIrange
	shimI = initI
	#current = 0


	shimlog[step + 1, 0:chnum] = shimI
	shimfield = rampshimBz(xyz=Bfield[:, 0:3], shimI=shimI)
	report, popt = signalfit(Bzfield=Bfield[:, 5], shimfield=shimfield, binumber=150,
					   chinfo='initial spectrum', expnumber=step, specplot=False, fitplot=True)
	shimlog[step + 1, chnum:chnum + 3] = report
	shimlog[step + 1, chnum + 3:chnum + 6] = popt
	if verbose:
		print('spectrum: height = %g [a.u.], fullwidth = %g kHz, peakloc = %g MHz' % (report[0], 1000 * report[1], report[2]))
		print('fit: height = %g [a.u.], linewidth = %g kHz, peakloc = %g MHz' % (popt[0], 1000 * popt[1], popt[2]))

	step += 1
	# record best
	shimlog[0, 0:chnum] = shimI
	shimlog[0, chnum:chnum + 3] = report
	shimlog[0, chnum + 3:chnum + 6] = popt


	shimch_i = 0

	while(step<=maxstep):
		# shim channel X
		shimch = sequence1stpass[shimch_i]
		layer += 1
		currange = np.linspace(start=shimrange[chindx(shimch), 0], stop=shimrange[chindx(shimch), 1], num=divnum, endpoint=True)
		for i in range(chnum):
			shimI[i] = shimlog[0,i]
		for current in currange:
			# check quench
			if current < min(shimIlim[chindx(shimch)]) or current > max(shimIlim[chindx(shimch)]):
				print("Quench warning !")
				print("channel " + shimch + " limit  %g to %g" % (
					min(shimIlim[chindx(shimch)]), max(shimIlim[chindx(shimch)])))
				print("channel " + shimch + " current set to ", current)
				return -100
			# set current
			shimI[chindx(shimch)] = current
			shimlog[step + 1, 0:chnum] = shimI
			shimfield = rampshimBz(xyz=Bfield[:, 0:3], shimI=shimI)
			if verbose:
				print('iteration = ', step)
				print('current paras = ', shimI)
				print('current paras = [%g,%g,%g,%g,%g,%g,%g,%g]' % (
				shimI[0], shimI[1], shimI[2], shimI[3], shimI[4], shimI[5], shimI[6],
				shimI[7]))
				print('best paras = [%g,%g,%g,%g,%g,%g,%g,%g]'%(shimlog[0,0],shimlog[0,1],shimlog[0,2],shimlog[0,3],shimlog[0,4],shimlog[0,5],shimlog[0,6],shimlog[0,7]))
			report, popt= signalfit(Bzfield=Bfield[:, 5], shimfield=shimfield, binumber=200,
							   chinfo='channel ' + shimch + ' current = %g' % (current), expnumber=step, specplot=False,
							   fitplot=False)
			shimlog[step + 1, chnum:chnum + 3] = report
			shimlog[step + 1, chnum+3:chnum + 6] = popt
			if verbose:
				print('spectrum: height = %g [a.u.], fullwidth = %g kHz, peakloc = %g MHz' % (
				report[0], 1000 * report[1], report[2]))
				print('fit: height = %g [a.u.], linewidth = %g kHz, peakloc = %g MHz\n' % (
				popt[0], 1000 * popt[1], popt[2]))
			step += 1

			improve = (report[0] - shimlog[0, chnum]) / shimlog[0, chnum]
			if improve > 0:
				# record best
				shimlog[0, 0:chnum] = shimI
				shimlog[0, chnum:chnum + 3] = report
				shimlog[0, chnum + 3:chnum + 6] = popt
				# update shim range
				shimrange[chindx(shimch), 0] = max(current - abs(currange[1] - currange[0]),
												   shimIlim[chindx(shimch), 0])
				shimrange[chindx(shimch), 1] = min(current + abs(currange[1] - currange[0]),
												   shimIlim[chindx(shimch), 1])
				#signalfit(Bzfield=Bfield[:, 5], shimfield=shimfield, binumber=200,chinfo=shimch, expnumber=step, specplot=False, fitplot=True)
			if improve > 0.1:
				shimch_i = 0
				break
			if step>maxstep:
				break
		if improve<=0.1:
			shimch_i+=1
		if shimch_i >=10:
			shimch_i = 0
		if step > maxstep:
			break


	shimfield = rampshimBz(xyz=Bfield[:, 0:3], shimI=shimlog[0, 0:chnum])
	signalfit(Bzfield=Bfield[:, 5], shimfield=shimfield, binumber=150, chinfo='best', expnumber=0, specplot=False,
			  fitplot=True)

	shimIlog = np.array([[0, 0, 0, 0, 0, 0, 0, 0], shimlog[0,0:chnum]])
	fitlog = np.array([shimlog[1,chnum:], shimlog[0,chnum:]])
	shiminfo = np.array(['No shimming', 'First-pass algorithm (took 63 steps)'])
	plotcolor = ['#1F77B4','#FF7F0E','#2CA02C','#D62728','#9467BD','#9D6F65']

	#shimIlog = np.zeros((2,len(shimlog[1])))
	#shimIlog[0]=shimlog[1]

	fig = plt.figure(figsize=(7, 4))  #
	gs = gridspec.GridSpec(nrows=1, ncols=1)  # , width_ratios=widths, height_ratios=heights
	# fig.subplots_adjust(left=0.23, bottom=0.157, right=0.971, top=0.974, wspace=0.2, hspace=0.2)
	ax0 = fig.add_subplot(gs[0, 0])

	for i in range(len(shimIlog[:, 0])):
		shimI = shimIlog[i]
		print(shimI)
		shimfield = rampshimBz(xyz=Bfield[:, 0:3], shimI=shimI)
		spectrum, bin_edges = np.histogram(gp * (Bfield[:, 5] + cpfactor * shimfield), bins=200, density=True)  #
		frequencies = (bin_edges - (bin_edges[1] - bin_edges[0]) / 2.)[1:]
		ax0.scatter(frequencies, spectrum, label=shiminfo[i], c=plotcolor[i],marker='o',s=10)
		ax0.plot(frequencies, Lorentzian(frequencies, *fitlog[i, 3:6]), plotcolor[i+2])
	# ax0.set_xlim(4.2, 4.30)
	# ax0.set_ylim(-20, 800)
	ax0.set_xlabel('Frequency [MHz]')
	ax0.set_ylabel('Signal power density [MHz$^-1$]')
	ax0.legend(loc='upper left')  # , fontsize=14
	ax0.set_title('spectra')
	# plt.savefig('1pulse/' + str(expnumber) + '/fit.pdf')
	plt.grid()
	plt.show()
	#for current in np.linspace(start=shimrange[chindx('X'),0], stop=shimrange[chindx('X'),1])
	return 0

def	signalplot(
		shimIlog=np.array([[0, 0, 0,0, 0, 0, 0, 0], [0, 0, 0, 3, 2, 2, -2, 0], [ 0.,-1.2,0.,0.,0.,0.,1.,2.]]),
		shiminfo=np.array(['No shimming','dumb sweep','First pass']),
		plotcolor=['r','g','b']
):
	Bfield = np.loadtxt(Bdataset_00_00_00)
	fitlog = np.zeros((len(shimIlog[:,0]),6))

	fig = plt.figure(figsize=(7, 4))  #
	gs = gridspec.GridSpec(nrows=1, ncols=1)  # , width_ratios=widths, height_ratios=heights
	# fig.subplots_adjust(left=0.23, bottom=0.157, right=0.971, top=0.974, wspace=0.2, hspace=0.2)
	ax0 = fig.add_subplot(gs[0, 0])

	for i in range(len(shimIlog[:,0])):
		shimI=shimIlog[i]
		print(shimI)
		shimfield = rampshimBz(xyz=Bfield[:, 0:3], shimI=shimI)
		spectrum, bin_edges = np.histogram(gp * (Bfield[:, 5] + cpfactor * shimfield), bins=200, density=True)  #
		frequencies = (bin_edges - (bin_edges[1] - bin_edges[0]) / 2.)[1:]
		ax0.plot(frequencies, spectrum,label=shiminfo[i],c=plotcolor[i])
		amp, sigma, peakloc, left, right = fitpara(xdata=frequencies, ydata=spectrum)
		fitlog[i, 0] = amp
		fitlog[i,1] = abs(frequencies[-1]-frequencies[0])
		fitlog[i, 2] = peakloc
		fitlog[i, 3:6], pcov = curve_fit(Lorentzian, frequencies[max(0, left - 2):right], spectrum[max(0, left - 2):right], \
							   p0=(amp, sigma, peakloc))  # ,method='lm'
		perr = np.sqrt(np.diag(pcov))
		ax0.plot(frequencies, Lorentzian(frequencies, *fitlog[i, 3:6]),plotcolor[i]+'--')


	#ax0.set_xlim(4.2, 4.30)
	#ax0.set_ylim(-20, 800)
	ax0.legend(loc='upper left')  #  , fontsize=14
	ax0.set_title('spectrum')
	# plt.savefig('1pulse/' + str(expnumber) + '/fit.pdf')
	plt.grid()
	plt.show()

swopt=0
if swopt==0:
	SHIMby1stpass(
		verbose=True,
		txtlog=True,
		radialsweep=False,
		orientation="height",
		maxstep=100,
		maxtime=60,
		chnum=8,
		initI=np.zeros(8),
		initIrange=np.array([[-2, 3], [-2, 3], [-2, 3], [-2, 3], [-2, 3], [-2, 3], [-2, 3], [-2, 3]])
	)

if swopt==1:
	SHIMbysweep(
		verbose=True,
		txtlog=True,
		radialsweep=False,
		orientation="height",
		maxstep=300,
		maxtime=60,
		chnum=8,
		initI=np.zeros(8),
		initIrange=np.array([[-20, 30], [-20, 30], [-20, 30], [-20, 30], [-20, 30], [-20, 30], [-20, 30], [-20, 30]])
	)

if swopt==2:
	signalplot(
		shimIlog=np.array([[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 2, 2, -2, 0],[0,0.8,0,3,-2,-1.8,-2,2]]),
		shiminfo=np.array(['No shimming', 'dumb sweep', 'First pass'])
	)
#[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 2, 2, -2, 0], [0., -1.2, 0., 0., 0., 0., 1., 2.]
#[ 0.,0.,0., 2.4,0.,-2.,-2.,0. ]