import numpy as np
from scipy import signal
import matplotlib.pyplot as plt
from matplotlib.colors import LogNorm
import matplotlib.gridspec as gridspec

import time
import sys
from lmfit import Parameters, minimize, report_fit, Model
from scipy.optimize import curve_fit



def Lorentzian(
		x=1,
		amp=1,
		pkloc = 0,
		FWHM=50
):
	return  amp / (1 + ((x - pkloc) / (0.5 * FWHM)) ** 2)

# gyromagnetic ratio
gp = 4.25775*10**1
# B field data generated by simulation for testing algorithm
Bdataset_00_00_00 = "Mag_Map_2021_0901 (17).txt"
Bdataset_00_00_05 = "Mag_Map_2021_0901 (2).txt"
Bdataset_00_00_10 = "Mag_Map_2021_0901 (3).txt"
Bdataset_00_05_00 = "Mag_Map_2021_0901 (4).txt"
Bdataset_00_05_05 = "Mag_Map_2021_0901 (5).txt"
Bdataset_00_05_10 = "Mag_Map_2021_0901 (6).txt"
Bdataset_05_00_00 = "Mag_Map_2021_0901 (7).txt"
Bdataset_05_00_05 = "Mag_Map_2021_0901 (8).txt"
Bdataset_05_00_10 = "Mag_Map_2021_0901 (9).txt"
Bdataset_05_05_00 = "Mag_Map_2021_0901 (10).txt"
Bdataset_05_05_05 = "Mag_Map_2021_0901 (11).txt"
Bdataset_05_05_10 = "Mag_Map_2021_0901 (12).txt"

# current limit for each channel in amp. should it be [-2, 3]?
chlim = np.array([[-2,3],[-2,3],[-2,3],[-2,3],[-2,3],[-2,3],[-2,3],[-2,3]])

def chindx(
		channelname = 'X'
):
	"""
	    Channel A ---> Shim X
		Channel B ---> Shim Z1
		Channel C ---> Shim Y
		Channel D ---> Shim Z2
		Channel E ---> Shim XY
		Channel F ---> Shim ZX
		Channel G ---> Shim ZY
		Channel H ---> Shim X2-Y2
	"""
	switch = {
		'X': 0, 'x': 0,
		'Z1': 1, 'z1': 1, 'Z': 1, 'z': 1,
		'Y': 2, 'y': 2,
		'Z2': 3, 'z2': 3,
		'XY': 4, 'xy': 4, 'Xy': 4,'xY': 4, 'YX': 4, 'yx': 4, 'yX': 4,'Yx': 4,
		'ZX': 5, 'zx': 5, 'Zx': 5, 'zX': 5, 'XZ': 5, 'xz': 5, 'xZ': 5, 'Xz': 5,
		'ZY': 6, 'zy': 6, 'Zy': 6, 'zY': 6, 'YZ': 6, 'yz': 6, 'yZ': 6, 'Yz': 6,
		'X2-Y2': 7, 'x2-y2': 7, 'X2Y2': 7,'x2y2': 7,
	}
	return switch.get(channelname, 1123)

def SHIMbysweep(

):
    """
    do shimming by sweeping parameter space of all channels

    """

    return 0

def rampshimBz(
		xyz=np.zeros((1000,3)),
		shimI = np.zeros(8)
):
	'''
	'''
	Bz = shimI[chindx('X')]*xyz[:,0]+shimI[chindx('Y')]*xyz[:,1]+shimI[chindx('Z')]*xyz[:,2]+\
		 shimI[chindx('XY')]*xyz[:,0]*xyz[:,1]+shimI[chindx('ZX')]*xyz[:,2]*xyz[:,0]+shimI[chindx('ZY')]*xyz[:,2]*xyz[:,1]+ \
		 shimI[chindx('Z2')] * (xyz[:, 2]**2 - xyz[:, 0]**2 - xyz[:, 1]**2)+\
		 shimI[chindx('X2-Y2')] * (xyz[:, 0]**2 - xyz[:, 1]**2)
	return Bz

def signalfit(
		Bzfield,
		shimfield,
		binumber = 1000
):
	spectrum, bin_edges = np.histogram(gp*Bzfield, bins=binumber, density=False) #, range=(267.3,267.7)
	frequencies = (bin_edges - (bin_edges[1]-bin_edges[0])/2.)[1:]

	fig = plt.figure()  # figsize=(3, 2.3)
	gs = gridspec.GridSpec(nrows=1, ncols=1)  # , width_ratios=widths, height_ratios=heights
	#fig.subplots_adjust(left=0.23, bottom=0.157, right=0.971, top=0.974, wspace=0.2, hspace=0.2)
	ax0 = fig.add_subplot(gs[0, 0])
	ax0.plot(frequencies, spectrum)  # ,label = labelarr[i]  ,c='grey'
	#ax0.set_xlim(307.6, 324.89)
	#ax0.set_ylim(0.2237, 0.2676)
	ax0.set_xlabel("frequency [MHz]")  # , fontsize=10
	ax0.set_ylabel("Amplitude [a.u.]")  # , fontsize=10
	#plt.savefig("D:\\Mainz\\JGU\\Specmeter\\report\\sample02mM0629UVzoomin1.png", format='png')
	plt.show()

	'''
	fitModel = Model(Lorentzian)
	gamma = 0.1
	popt, pcov = curve_fit(Lorentzian, frequencies, spectrum, p0=(frequencies[np.argmax(spectrum)], 0.1, 0.1, 0))
	plt.plot(frequencies, Lorentzian(frequencies, *popt), 'g--',
			 label='fit: a=%5.3f, b=%5.3f, c=%5.3f, d=%5.3f' % tuple(popt))
	plt.plot(frequencies, spectrum)
	plt.title('fit: center=%5.3f, linewidth=%5.3f, area=%5.3f, expnumber=%d' % (popt[0], popt[1], popt[2], expnumber))
	#plt.savefig('1pulse/' + str(expnumber) + '/fit.pdf')
	plt.close()
	plt.figure()
	# center, FWHM, area
	sys.stdout.write('%5.3f, %5.3f, %5.3f' % (popt[0], popt[1], popt[2]))
	return popt[1]
	'''
	return 0

def SHIMby1stpass(
    verbose=True,
	txtlog=True,
	radialsweep = False,
	orientation = "height",
	maxstep=300,
	maxtime=60,
		chnum = 8,
		initI = np.zeros(8),
		initIrange = np.array([[-2,3],[-2,3],[-2,3],[-2,3],[-2,3],[-2,3],[-2,3],[-2,3]])
):
	"""
	shimming algorithm: First pass.
	    See book Shimming Ain't Magic: The Shimming of High Resolution NMR Magnets by V. W. Miner and W. W. Conover
	"""
	Bfield = np.loadtxt("Mag_Map_2021_0901 (20).txt")
	print("shape of B field = ", Bfield.shape)
	# shim log format
	# chA B ... until H (fit)height FWHM area peakposition
	shimlog = np.zeros((maxstep+1,chnum+6))
	shimrange = initIrange
	shimI = initI
	shimfield = np.zeros((Bfield[0,:]).shape)

	print("shape of shimfield = ", shimfield.shape)
	step = 0
	layer = 0
	improvement = 0
	current = 0
	while(step<=maxstep):
		for current in np.linspace(start=shimrange[chindx('Z1'), 0], stop=shimrange[chindx('Z1'), 1],
								   num=5,endpoint=True):
			shimI[chindx('X')] = current
			shimfield = rampshimBz(xyz=Bfield[:, 0:3], shimI=shimI)
			signalfit(Bzfield=Bfield[:, 5], shimfield=shimfield,binumber=200)
			maxstep+=1
		#for current in np.linspace(start=shimrange[chindx('X'),0], stop=shimrange[chindx('X'),1])
	return 0

SHIMby1stpass(
    verbose=True,
	txtlog=True,
	radialsweep = False,
	orientation = "height",
	maxstep=300,
	maxtime=60,
		chnum = 8,
		initI = np.zeros(8),
		initIrange = np.array([[-2,3],[-2,3],[-2,3],[-2,3],[-2,3],[-2,3],[-2,3],[-2,3]])
)